# 垃圾回收

## 引用计数法

循环引用无法被移除

## 根可达算法

通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

### 固定可作为GC Roots的对象
1. 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
2. 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
3. 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
4. Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
5. 所有被同步锁（synchronized关键字）持有的对象。
6. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

## 分代收集
1. 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
2. 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。

## 标记-清除算法 Mark-Sweep

算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象  
缺点  
1. 执行效率不稳定
2. 内存空间碎片化

## 标记-复制 Mark-Copy

标记-复制算法常被简称为复制算法它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。  
缺点：
1. 内存复制开销
2. 可用内存变小

## 标记-整理 Mark-Compact

标记-整理算法其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存  

标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策：如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序(STW问题)才能进行

## 垃圾收集器

### Serial收集器