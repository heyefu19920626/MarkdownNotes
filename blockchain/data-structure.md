# 数据结构


- [数据结构](#数据结构)
  - [基础](#基础)
  - [线性表](#线性表)
  - [栈与队列](#栈与队列)
  - [串,字符串](#串字符串)
  - [树](#树)
    - [Merkle Tree](#merkle-tree)
  - [图](#图)
  - [图的存储结构](#图的存储结构)
    - [邻接矩阵](#邻接矩阵)
      - [网](#网)
    - [邻接表（Adjacency List）](#邻接表adjacency-list)

## 基础

1. 逻辑结构
   1. 集合结构
   2. 线性结构
   3. 数形结构
   4. 图形结构
2. 物理结构
   1. 线性存储结构
   2. 链式存储结构
3. 算法的五种基本特性：输入，输出，有穷性，确定性和可行性

## 线性表

1. 数组
2. 单链表
   1. 头插法
   2. 尾插法
3. 静态链表
   1. 用数组描述的链表
   2. 使用游标实现法，数组的每个下标都对应着一个data和cur，cur存放后继元素在数组的下标
   3. 数组建立大一些，未使用的数组称为备用链表，数组第一个和最后一个作为特殊元素，第一个元素存放备用链表的第一个节点的下标，最后一个元素存放第一个有值的元素的下标
   4. 静态链表的申请和释放
      1. 将所有未被使用过的及已删除的游标分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得一个节点作为待插入的新节点
   5. 循环链表
      1. 将单链表中终端的指针右空指针改为指向头节点
      2. 尾指针
   6. 双向链表
      1. 在单链表的每个结构中，再设置一个指向其前驱节点的指针域
      2. 在插入和删除使指针的更改顺序至关重要

## 栈与队列

栈是限定只在表尾进行插入和删除操作的线性表  
队列是只允许在一端插入，而在另一端删除的线性表
1. 顺序栈,Stack
   1. 栈顶，栈底,后进先出;进栈，压栈，入栈；出栈
   2. 一般用数组，长度为-1时为空
   3. *两栈共享空间*,一般使用在有相反需求的关系时
2. 链栈
3. 栈的应用
   1. 递归
   2. 四则运算，遇左括号入栈，遇右括号出顶栈,运算结果进栈
      1. 后缀表达式`9+(3-1)*3+10/2`, `9 3 1 - 3 * + 10 2 / +`
      2. 中缀表达式转后缀表达式:从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止
4. 队列，First in first out,允许插入的一端称队尾，允许删除的一端称队头,尾指针一般指向队尾的下一个元素，当头指针等于尾指针时说明队列位空
5. 循环队列：头尾相接的顺序存储结构组成的队列
   1. 队满判断：设置一个标志变量；修改队满条件，保留一个空元素,此时判定条件为`(rear+1)%QueueSize=front`,队列长度计算公式为`(rear-front+QueueSize)%QueueSize`
6. 链队列

## 串,字符串

ASCII： 7位二进制->扩展为8位二进制  
UNICODE： 16位二进制  
1. 串的顺序存储
2. 串的链式存储,一个节点可以存储多个字符，最后一个节点未满时使用结束符
3. 朴素的匹配模式算法
   1. 对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配，对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或全部遍历完成为止,时间复杂度位O{(n-m+1)*m},m为子串长度
   2. 如在00000001中查找001
4. KMP模式匹配算法
   1. 假设`S="abcabcabc",T="abcabx"`,i为循环中S主串当前位置的下标，j为子串当前位置的下标(j从1开始？)
   2. 主要为求next[j]的值:next[j]表示当前模式串T的j下标对目标串S的i值失配时，我们应该使用模式串的下标为next[j]接着去和目标串失配的i值进行匹配
   3. next[j]={0,j=1;max{k|1<k<j, $p_1,p_2,...,p_{k-1}=p_{j-k+1},p_{j-k+2},...,p_{j-1}$}}
   4. `T="ababaaaba",next="011234223"`
$$
        next[j] =
        \begin{cases}
        0,  & \text{j=1} \\
        max\{ k | 1<k<j, p_1,p_2,...,p_{k-1}=p_{j-k+1},p_{j-k+2},...,p_{j-1}\} \\
        1,  & \text{其他} \\
        \end{cases}
$$

## 树

树是n(n>=0)个节点的有限集。n=0时称为空树，在任意一个非空树中：
1. 有且仅有一个特定的称为根(root)的节点
2. 当n>1时，其余节点可分为m(m>0)个互不相交的有限集$T_1,T_2,...,T_m$,其中每一个集合本身又是一颗树，并且称为根的子树(SubTree)

1. 节点分类
   1. 节点拥有的子树数称为度(Degree)
   2. 度为0的节点称为叶节点或终端节点(Leaf);度不为0的节点称为分支节点；除根节点以外，分支节点也称为内部节点
   3. 树的度是树内各节点度的最大值
2. 节点的层次(Level)
   1. 根为第一层
   2. 节点的最大层次称为树的深度(Depth)
3. 有序树与无序树；森林
4. 树的顺序存储结构
   1. 双亲表示法:根的双亲域设置为-1;可以扩展增加长子域，兄弟域等(每个节点右数据+双亲域构成)
   2. 孩子表示法:把每个节点的孩子节点(孩子节点由该孩子的下标+下一个孩子的位置的指针组成)排列起来，以单链表作为存储结构，则n个节点有n个孩子链表，如果是叶子节点则此单链表为空，然后n个头指针又组成一个线性表(线性表存储真正的节点，每个节点由数据+第一个孩子的指针组成)，采用顺序存储结构,存放入一个一维数组
      1. 每个节点有多个指针域，其中每个指针指向一颗子树的根节点
      2. 指针域的个数等于树的度
      3. 每个节点指针域的个数等于该节点的度，专门取一个位置来存储节点指针域的个数
   3. 孩子兄弟表示法:任意一棵树，它的节点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的
      1. 把复杂的一棵树变成了二叉树
5. 二叉树(Binary Tree)是n(n>=0)个节点的有限集合，该集合或者为空集，或者由一个根节点和两颗互不交叉的，分别称为根节点的左子树与右子树的二叉树组成
   1. 每个节点最多有两颗子树
   2. 左子树与右子树是有顺序的，不能任意颠倒
   3. 即使树中某节点只有一颗子树，也要区分是左子树还是右子树
6. 特殊二叉树
   1. 斜树
   2. 满二叉树:所有分支节点都存在左右子树，并且所有叶子节点都在同一层上
   3. 完全二叉树:对一颗具有n个节点的二叉树按层序编号(根节点为1，同层节点从左向右增大序号)，如果编号位i(1<=i<=n)的节点与同样深度的满二叉树中编号为i的节点在二叉树中的位置完全相同，则这颗树称为完全二叉树
      1. 叶子节点只能出现在最下两层
      2. 最下层的叶子一定集中在左部连续位置
      3. 倒数二层，若有叶子节点，一定在右部连续位置
      4. 如果节点度为1，则该节点只有左孩子，即不存在只有右子树的情况
      5. 同样节点的二叉树，完全二叉树的深度最小
7. 二叉树的性质
   1. 在二叉树的i层，至多有$2^{i-1}$个节点
   2. 深度为k的二叉树，至多有$2^k-1$个节点
   3. 对于一颗二叉树T,如果其终端节点树为$n_0$,度为2的节点数为$n_2$,则$n_0=n_2+1$;根据分支线总数与节点总数推算得到;$分支线总数=n-1=n_1+2n_2, n=n_0+n_1+n_2$
   4. 具有n个节点的完全二叉树的深度为$[log_2n] + 1([x]表示不大于x的最大整数)$
   5. 如果对一颗有n个节点的完全二叉树的节点按层序编号，对任一节点i(1<=i<=n)有
      1. 如果i=1，则节点i是二叉树的根，无双亲，若i>1,则其双亲节点是[i/2]
      2. 如果2i>n,则节点i无左孩子(节点i为叶子节点)，否则其左孩子是节点2i
      3. 如果2i+1>n,则节点i无右孩子，否则其右孩子为2i+1
8. 二叉树的存储结构
   1. 顺序存储结构，完全二叉树，按序号存储，不存在的节点为空
   2. 链式存储结构
9. 遍历二叉树
   1.  二叉树的遍历(traversing binary tree)是指从根节点出发，按照某种次序依次访问二叉树中的所有节点，使得每个节点被访问一次且仅被访问一次
   2.  前序遍历: 若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树
   3.  中序遍历: 若二叉树为空，则空操作返回，否则从根节点开始(注意并不是先访问根节点),中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树
   4.  后序遍历: 若二叉树为空，则空操作返回，否则从左到右先叶子后节点的方式遍历访问左右子树，最后是访问根节点
   5.  层序遍历: 若二叉树为空，则空操作返回，否则从树的第一层，也就是根节点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对节点逐个访问
   6.  遍历性质
       1.  已知前序遍历序列和中序遍历序列，可以确定唯一一颗二叉树
       2.  已知后序遍历序列和中序遍历序列，可以确定唯一一颗二叉树
       3.  已知前序和后序，是不能确定唯一一颗二叉树的，例如：前序序列ABC，后序序列CBA
10. 二叉树的建立
    1.  扩展二叉树：将二叉树的每个节点的空指针引出一个虚拟节点，其值为一特定值，比如"#",扩展二叉树可以做到一个遍历序列确定一颗二叉树
    2.  根据这个序列比如：AB#D##C##为前序序列，输入程序递归解析就可得到一颗二叉树
11. 线索二叉树
    1.  对于一个有n个节点的二叉链表，每个节点都有指向左右还在的指针域，一共2n个指针域，而n个节点的二叉树共有n-1条分支线，总共存在2n-(n-1)=n+1空指针域
    2.  指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree).前驱后后继根据遍历顺序的不同而不同
    3.  对二叉树以某种次序遍历使其变为线索二叉树的过程称为线索化
    4.  为了区别lchild是左孩子还是前驱，需要增加一个ltag，同样，需要增加一个rtag
    5.  可以在线索二叉树上加一个头节点，使头结点的左指针指向二叉树的根节点，使头结点的右指针指向中序遍历时访问的最后一个节点；反之，让中序访问的第一个节点的左指针和中序访问的最后一个节点的右指针指向头节点
12. 树，森林与二叉树的交换
    1. 树的孩子兄弟法可以将一棵树用二叉链表进行存储，所以借助二叉链表，树和二叉树可以相互转换
    2. 树转换为二叉树
       1. 加线，在所有兄弟节点之间加一条线
       2. 去线，对树中每个节点，只保留它与第一个孩子的连线，删除它与其他孩子的连线
       3. 层次调整，以树的根节点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明，注意第一个孩子是二叉树节点的左孩子，兄弟转换过来的孩子是节点的右孩子
    3. 森林转换为二叉树
       1. 把每棵树转换为二叉树
       2. 第一颗二叉树不动，从第二棵二叉树开始，依次把后一颗二叉树的根节点作为前一颗二叉树根节点的右孩子，用线连接起来
    4. 二叉树转换为树
       1. 加线，若某节点的左孩子存在，则将该左孩子(A)的右孩子，(A的)右孩子的右孩子,(A的)右孩子的右孩子的右孩子...即左孩子的n个右孩子节点都作为此节点的孩子，将该节点与这些右孩子节点连接起来
       2. 去线，删除原二叉树中所有节点与其右孩子的连线
       3. 层次调整，使其结构分明
    5. 二叉树转化为森林
       1. 二叉树的根节点如果有右孩子，就是森林，反之就是一棵树
       2. 从根节点开始，若右孩子存在，则把与右孩子的连线删除，再查看分离后的二叉树，重复此步骤，直到所有右孩子的连线都删除为止
       3. 再将每颗分离后的二叉树转化为树
    6. 树与森林的遍历
       1. 树的遍历
          1. 先根遍历，即先访问树的根节点，然后依次先根遍历根节点的每个子树
          2. 后根遍历，即先依次后根遍历每颗子树，然后访问根节点
       2. 森林的遍历
          1. 前序遍历，先访问森林中的第一棵树的根节点，然后依次先根遍历根的每颗子树，再依次用同样的方式遍历除去第一棵树的剩余树的森林
          2. 后序遍历，先访问森林的第一棵树，后根遍历该树的每颗子树,然后再访问根节点，再依次用同样的方式遍历除去第一棵树的剩余树的森林
       3. 树的先根遍历和后根遍历可以借助二叉树的前序遍历和后序遍历算法来实现
13. 赫夫曼树
    1. 路径长度: 从树中一个节点到另一个节点之间的分支构成两个节点之间的路径，路径上的分支数目称为路径长度
    2. 树的路径长度就是从树根到每一个节点的路径长度之和
    3. 节点带权的路径长度为从该节点到树根之间的路径长度与节点上权的乘积，树的带权路径长度为树中所有叶子节点的带权路径长度之后，假设有n个权值${w_1, w_2, ... , w_n}$,构造一颗有n个叶子节点的二叉树，每个叶子节点带权$w_k$,每个叶子节点的路径长度为lk，我们通常记作，则其中带权路径长度WPL最小的二叉树称为赫夫曼树(也叫最优二叉树)
    4. 构造赫夫曼树
       1. 根据给定的n个权值${w_1,w_2,...,w_n}$构成n颗二叉树的集合$F={T_1,T_2,...,T_n}$,其中每颗二叉树$T_i$中只有一个带权节点位$w_i$根节点，其左右子树均为空
       2. 在F中选取两颗根节点的权值最小的树作为左右子树构造一颗新的二叉树，且置新的二叉树的根节点的权值为其左右子树上的根节点的权值之和
       3. 在F中删除这两颗树，同时将新得到的二叉树加入F中
       4. 重复2和3，直到F只含一棵树为止，这棵树边是赫夫曼树
    5. 赫夫曼编码： 一般地，设需要编码的字符集为${d_1,d_2,...,d_n}$,各个字符在电文中出现的次数或频率集合为${w_1,w_2,...,w_n}$,以$d_1,d_2,...,d_n$作为叶子节点，以$w_1,w_2,...,w_n$作为相应叶子节点的权值来构造一颗赫夫曼树，规定赫夫曼树的左分支代表0，有分支代表1，则从根节点到叶子节点所经过的路径分支组成的0和1的序列便为该节点对应字符的编码，这便是赫夫曼编码


### Merkle Tree

- Hash
    + Hash是一个把任意长度的数据映射成固定长度数据的函数
- Hash List(Hash List可以看作一种特殊的Merkle Tree，即树高为2的多叉Merkle Tree)
- Merkle Tree
    + MT是一种树，大多数是二叉树，也可以多叉树，无论是几叉树，它都具有树结构的所有特点
    + Merkle Tree的叶子节点的value是数据集合的单元数据或者单元数据HASH
    + 非叶子节点的value是根据它下面所有的叶子节点值，然后按照Hash算法计算而得出的

## 图

图(Graph)是由顶点的**有穷非空集合**和顶点之间边的集合组成，通常标识为:G(V,E),其中,G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

1. 图中数据元素，称之为顶点(Vertex)
2. 图不允许非空
3. 无向边，无向图
   1. ${G_1}=(V_1, \{E_1\})$,其中顶点集合$V_1=\{A,B,C,D\}$,边集合$E_1=\{(A,B),(B,C),(C,D),(D,A),(A,C)\}$
4. 有向图，弧
   1. ${G_1}=(V_2, \{E_2\})$,其中顶点集合$V_1=\{A,B,C,D\}$,边集合$E_1=\{<A,B>,<B,C>,<C,D>,<D,A>,<A,C>\}$
   2. 顶点的度数，入度和出度
5. 简单图
   1. 在图中，，若不存在顶点到其自身的边，且同一条边不重复出现
6. 无向完全图
   1. 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图
7. 路径
   1. 路径的长度是路径上边或弧的数目
   2. 第一个顶点到最后一个顶点相同的路径称为回路或环
   3. 序列中不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复的出现的回路，称为简单回路或简单环。
8. 连通图
   1. 在无向图G中，如果从顶点v到顶点$v^1$有路径，则称v和$v^1$是连通的
   2. 如果对于图中任意两个顶点 $v_i, v_j \in E$，$v_i, v_j$都是连通的，则称G是连通图
   3. 无向图中的极大连通子图称为连通分量
      1. 要是子图
      2. 子图要是连通的
      3. 连通子图含有极大定点数
      4. 具有极大顶点数的连通子图包含依附于这些顶点的所有边
9. 强连通图
   1.  在有向图G中，如果对于每一对$v_i,v_j \in V, v_i \neq v_j,从v_i到v_j和从v_j到v_i$都存在路径，，则称G是强连通图
   2.  有向图中的极大强连通子图称作有向图的强连通分量
10. 生成树
    1.  一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边
11. 有向树
    1.  如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一颗有向树
    2.  一个有向图的生成森林由若干颗有向树组成，，含有图中全部顶点，但只有足以构成若干颗不相交的有向树的弧


## 图的存储结构


### 邻接矩阵

图的邻接矩阵存储方式是用两个数组来来表示图。一个一维数组存储图中的顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息  
设图G有n个顶点，则邻接矩阵是一个$n \times n$的方阵，定义为  
$$
        arc[i][j] =
        \begin{cases}
        1, 若(v_i,v_j) \in E或<v_i,v_j> \in E \\
        0,  反之 \\
        \end{cases}
$$

#### 网

每条边上带有权的图叫做网  

设图G是网图，有n个顶点，则邻接矩阵是一个$n \times n$的方阵，定义为  
$$
        arc[i][j] =
        \begin{cases}
        W_{ij}, 若(v_i,v_j) \in E或<v_i,v_j> \in E \\
        0, 若i = j  反之 \\
        \infty, 反之 \\
        \end{cases}
$$

这里$W_{ij}表示(v_i,v_j)或<v_i,v_j>$上的权值

### 邻接表（Adjacency List）

数组与链表相结合的存储方法称为邻接表。  

1. 图中顶点用一个一维数组或单链表来存储，每个数据元素还需要存储指向第一个邻接点的额指针，以便于查找该顶点的边信息
2. 图中每个顶点$v_i$的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点$v_i$的边表，有向图则称为顶点$v_i$作为弧尾的出边表